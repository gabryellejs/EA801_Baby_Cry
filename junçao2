from machine import Pin, PWM, ADC, SoftI2C
import ssd1306
import time, utime, array, math

# ======= Display e Buzzer =======
buzzer = PWM(Pin(21))  # Buzzer
botao = Pin(5, Pin.IN, Pin.PULL_UP)
i2c_oled = SoftI2C(scl=Pin(15), sda=Pin(14))
oled = ssd1306.SSD1306_I2C(128, 64, i2c_oled)

NOTAS = {
    "C4": 262, "D4": 294, "E4": 330, "F4": 349,
    "G4": 392, "A4": 440, "B4": 494, "C5": 523
}
MUSICA = [
    ("C4", 0.5), ("D4", 0.5), ("E4", 0.5), ("F4", 0.5), ("G4", 0.5),
    ("G4", 0.5), ("A4", 0.5), ("G4", 1.0), ("G4", 0.5), ("F4", 0.5),
    ("E4", 0.5), ("D4", 0.5), ("E4", 0.5), ("F4", 0.5), ("G4", 1.0),
    ("C4", 0.5), ("D4", 0.5), ("E4", 0.5), ("F4", 0.5), ("G4", 0.5),
    ("G4", 0.5), ("A4", 0.5), ("G4", 1.0), ("G4", 0.5), ("F4", 0.5),
    ("E4", 0.5), ("D4", 0.5), ("C4", 0.5), ("C4", 1.0)
]

def atualizar_display(linha1="", linha2=""):
    oled.fill(0)
    oled.text(linha1, 0, 20)
    oled.text(linha2, 0, 35)
    oled.show()

def tocar_nota(nota, duracao):
    if nota in NOTAS:
        buzzer.freq(NOTAS[nota])
        buzzer.duty_u16(30000)
        inicio = time.ticks_ms()
        while time.ticks_diff(time.ticks_ms(), inicio) < duracao * 1000:
            if botao.value() == 0:
                buzzer.duty_u16(0)
                atualizar_display("Musica", "interrompida")
                return False
        buzzer.duty_u16(0)
        time.sleep(0.01)
    return True

def tocar_musica():
    for nota, duracao in MUSICA:
        if not tocar_nota(nota, duracao):
            break

# ======= ParÃ¢metros de Amostragem =======
MIC_CHANNEL = 2
MIC_PIN = 26 + MIC_CHANNEL
SAMPLE_FREQ = 16000
SAMPLE_DURATION = 1
SAMPLES = SAMPLE_FREQ * SAMPLE_DURATION
SAMPLING_INTERVAL = 5
LOW_CUT = 400
HIGH_CUT = 6000
VOLTAGE_THRESHOLD = 0.0025
VREF = 3.3
MAX_ADC = 65535
ADC_ENERGY_THRESHOLD = VOLTAGE_THRESHOLD * (MAX_ADC / VREF) * (MAX_ADC / VREF)
USE_STATUS_LED = True
LED_PIN = 25

def design_bandpass_coefficients(low_freq, high_freq, sample_rate):
    f1 = max(0.01, min(0.99, low_freq / (sample_rate / 2)))
    f2 = max(f1 + 0.01, min(0.99, high_freq / (sample_rate / 2)))
    q = 1.0
    w0 = math.pi * (f1 + f2)
    bw = math.pi * (f2 - f1)
    alpha = math.sin(bw) / (2 * q)
    b0 = alpha
    b1 = 0
    b2 = -alpha
    a0 = 1 + alpha
    a1 = -2 * math.cos(w0)
    a2 = 1 - alpha
    b = [b0/a0, b1/a0, b2/a0]
    a = [1.0, a1/a0, a2/a0]
    return (b, a)

def apply_bandpass_filter(data, b, a):
    filtered = array.array('f')
    x1 = x2 = y1 = y2 = 0.0
    for x0 in data:
        y0 = (b[0]*x0 + b[1]*x1 + b[2]*x2 - a[1]*y1 - a[2]*y2)
        filtered.append(y0)
        x2, x1 = x1, x0
        y2, y1 = y1, y0
    return filtered

def calculate_energy(filtered_data):
    energy = sum(x * x for x in filtered_data) / len(filtered_data)
    return energy

def detect_baby_cry(adc_data):
    b, a = design_bandpass_coefficients(LOW_CUT, HIGH_CUT, SAMPLE_FREQ)
    filtered_data = apply_bandpass_filter(adc_data, b, a)
    energy = calculate_energy(filtered_data)
    return energy > ADC_ENERGY_THRESHOLD, energy

class MicrophoneSampler:
    def __init__(self):
        self.adc = ADC(Pin(MIC_PIN))
        self.adc_buffer = array.array('H', [0] * SAMPLES)
        self.sample_interval_us = 1000000 // SAMPLE_FREQ
        self.led = Pin(LED_PIN, Pin.OUT) if USE_STATUS_LED else None

    def sample_mic(self):
        start_time = utime.ticks_us()
        next_sample_time = start_time
        for i in range(SAMPLES):
            current_time = utime.ticks_us()
            if utime.ticks_diff(next_sample_time, current_time) > 0:
                utime.sleep_us(utime.ticks_diff(next_sample_time, current_time))
            self.adc_buffer[i] = self.adc.read_u16()
            next_sample_time = utime.ticks_add(start_time, (i + 1) * self.sample_interval_us)

    def signal_detection(self, is_crying):
        if not self.led:
            return
        if is_crying:
            for _ in range(3):
                self.led.value(1)
                utime.sleep_ms(100)
                self.led.value(0)
                utime.sleep_ms(100)
        else:
            self.led.value(1)
            utime.sleep_ms(200)
            self.led.value(0)

    def run(self):
        while True:
            atualizar_display("Monitorando", "som...")
            print("Amostrando...")
            self.sample_mic()
            is_crying, energy = detect_baby_cry(self.adc_buffer)
            print(f"Energy: {energy:.2f}")
            self.signal_detection(is_crying)
            if is_crying:
                atualizar_display("Choro", "detectado!")
                tocar_musica()
            time.sleep(SAMPLING_INTERVAL)

def main():
    try:
        import gc
        gc.collect()
    except:
        pass

    sampler = MicrophoneSampler()
    sampler.run()

if __name__ == "__main__":
    main()
